#!/usr/bin/env node

/**
 * merge components by stack's flavor,
 * to see all possible values of a stack's flavor
 * & extract typescript types
 */

const fs = require("fs");
const assert = require("assert");
const path = require("path");

async function generateStackComponentTsTypes() {
	const components = await fetchComponents();
	fs.writeFileSync("components.json", JSON.stringify(components, null, 4));

	const { stackComponentsByStackFlavor } = extractUniqueValuesFromComponents(components);

	const generatedTypesJSON = generateTSTypesJSON(stackComponentsByStackFlavor);
	const tsTypesStr = generateCompleteTypescriptDefinitionFile(generatedTypesJSON);

	fs.writeFileSync("stack-components.d.ts", tsTypesStr);
}

const API = "https://zenml-frontend-challenge-backend.fly.dev";

async function fetchComponents() {
	const res = await fetch(`${API}/components`);
	const components = await res.json();
	return components;
}

function generateCompleteTypescriptDefinitionFile(generatedTypesJSON) {
	const { generatedInterfaces, commonInterfaceName } = generateActualTypescriptTypes(generatedTypesJSON);

	const tsPrefix = `// generated by ${path.basename(__filename)}`;
	const tsTypesStr = [
		tsPrefix, //
		commonInterfaceName,
		...generatedInterfaces,
	].join("\n\n");

	return tsTypesStr;
}

function extractUniqueValuesFromComponents(components) {
	const stackComponentsByStackFlavor = new Map();

	for (const item of components) {
		if (!stackComponentsByStackFlavor.has(item.type)) {
			stackComponentsByStackFlavor.set(item.type, {});
		}

		traverseObjectCollectUniqueValues(stackComponentsByStackFlavor, item);
	}

	const uniqueValues = [...stackComponentsByStackFlavor.values()];
	return { uniqueValues, stackComponentsByStackFlavor };
}

function traverseObjectCollectUniqueValues(
	stackComponentsByStackFlavor,
	newItem, //
	curr = stackComponentsByStackFlavor.get(newItem.type)
) {
	for (const [key, val] of Object.entries(newItem)) {
		if (isObj(val)) {
			if (!(key in curr)) curr[key] = {};
			traverseObjectCollectUniqueValues(stackComponentsByStackFlavor, val, curr[key]);
		} else {
			if (!(key in curr)) curr[key] = [];
			if (!curr[key].includes(val)) curr[key].push(val);
		}
	}
}

function isObj(val) {
	return val instanceof Object && !Array.isArray(val);
}

function generateTSTypesJSON(
	stackComponentsByStackFlavor,
	obj = Object.fromEntries(stackComponentsByStackFlavor.entries()),
	types = {}
) {
	for (const [key, val] of Object.entries(obj)) {
		if (isObj(val)) {
			if (!(key in types)) types[key] = {};
			generateTSTypesJSON(stackComponentsByStackFlavor, val, types[key]);
		} else {
			if (key === "type") {
				/** infer const type */
				assert.deepStrictEqual(val.length, 1);
				types[key] = `"${val[0]}"`;
			} else {
				/** coalesce value */

				const hasString = val.some((x) => typeof x === "string");
				const hasNumber = val.some((x) => typeof x === "number");
				const hasBool = val.some((x) => x === true || x === false);
				const hasNull = val.some((x) => x === null);
				const hasUndefined = val.some((x) => x === undefined);
				const isEmpty = val.length === 0;

				const generatedKey = isEmpty ? `${key}?` : key;
				const generatedTypesTmp = isEmpty //
					? ["string"] /** default to strings since matches common behavior */
					: [
							hasString && "string", //
							hasNumber && "number",
							hasBool && "boolean",
							hasNull && "null",
							hasUndefined && "undefined",
						].filter((x) => x);

				console.log({ key, val, isEmpty, hasString });

				assert(
					generatedTypesTmp.length > 0,
					"value is not empty, but generated type is -- some matchers missing?"
				);

				const generatedType = generatedTypesTmp.join(" | ");
				types[generatedKey] = generatedType;
			}
		}
	}

	return types;
}

function generateActualTypescriptTypes(generatedTypes) {
	const generatedInterfaces = [];
	const interfaceNames = [];
	const PREFIX = "StackComponent";

	iterObj();

	const commonInterfaceName = `export type ${PREFIX} = ` + interfaceNames.join("\n\t| ") + ";";

	return { generatedInterfaces, interfaceNames, commonInterfaceName };

	function iterObj(obj = generatedTypes, parentInterface = generatedInterfaces) {
		for (const [key, value] of Object.entries(obj)) {
			const interface = [];

			const isRoot = parentInterface === generatedInterfaces;
			const name = `${PREFIX}_${key}`;
			const start = isRoot ? `export type ${name} = {` : `${key}: {`;

			if (isRoot) {
				interfaceNames.push(name);
			}
			interface.push(start);

			for (const [key2, val2] of Object.entries(value)) {
				if (isObj(val2)) {
					iterObj({ [key2]: val2 }, interface);
				} else {
					interface.push(`${key2}: ${val2};`);
				}
			}

			interface.push("};");

			parentInterface.push(interface.join("\n"));
		}
	}
}

if (!module.parent) {
	generateStackComponentTsTypes();
}
